<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="memory_addr"><title>memory_addr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-77263533.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="memory_addr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.94.0-nightly (f6a07efc8 2026-01-16)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7bab91a1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate memory_addr</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../memory_addr/index.html">memory_<wbr>addr</a><span class="version">0.4.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#memory_addr" title="memory_addr">memory_addr</a><ul><li><a href="#examples" title="Examples">Examples</a></li></ul></li></ul><h3><a href="#macros">Crate Items</a></h3><ul class="block"><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>memory_<wbr>addr</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/memory_addr/lib.rs.html#1-108">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="memory_addr"><a class="doc-anchor" href="#memory_addr">§</a>memory_addr</h2>
<p><a href="https://crates.io/crates/memory_addr"><img src="https://img.shields.io/crates/v/memory_addr" alt="Crates.io" /></a>
<a href="https://docs.rs/memory_addr"><img src="https://docs.rs/memory_addr/badge.svg" alt="Docs.rs" /></a>
<a href="https://github.com/arceos-org/axmm_crates/actions/workflows/ci.yml"><img src="https://github.com/arceos-org/axmm_crates/actions/workflows/ci.yml/badge.svg?branch=main" alt="CI" /></a></p>
<p>Wrappers and helper functions for physical and virtual memory addresses.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>memory_addr::{pa, va, va_range, PhysAddr, VirtAddr, MemoryAddr};

<span class="kw">let </span>phys_addr = PhysAddr::from(<span class="number">0x12345678</span>);
<span class="kw">let </span>virt_addr = VirtAddr::from(<span class="number">0x87654321</span>);

<span class="macro">assert_eq!</span>(phys_addr.align_down(<span class="number">0x1000usize</span>), <span class="macro">pa!</span>(<span class="number">0x12345000</span>));
<span class="macro">assert_eq!</span>(phys_addr.align_offset_4k(), <span class="number">0x678</span>);
<span class="macro">assert_eq!</span>(virt_addr.align_up_4k(), <span class="macro">va!</span>(<span class="number">0x87655000</span>));
<span class="macro">assert!</span>(!virt_addr.is_aligned_4k());
<span class="macro">assert!</span>(<span class="macro">va!</span>(<span class="number">0xabcedf0</span>).is_aligned(<span class="number">16usize</span>));

<span class="kw">let </span>va_range = <span class="macro">va_range!</span>(<span class="number">0x87654000</span>..<span class="number">0x87655000</span>);
<span class="macro">assert_eq!</span>(va_range.start, <span class="macro">va!</span>(<span class="number">0x87654000</span>));
<span class="macro">assert_eq!</span>(va_range.size(), <span class="number">0x1000</span>);
<span class="macro">assert!</span>(va_range.contains(virt_addr));
<span class="macro">assert!</span>(va_range.contains_range(<span class="macro">va_range!</span>(virt_addr..virt_addr + <span class="number">0x100</span>)));
<span class="macro">assert!</span>(!va_range.contains_range(<span class="macro">va_range!</span>(virt_addr..virt_addr + <span class="number">0x1000</span>)));</code></pre></div></div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.addr_range.html" title="macro memory_addr::addr_range">addr_<wbr>range</a></dt><dd>Converts the given range expression into <a href="struct.AddrRange.html" title="struct memory_addr::AddrRange"><code>AddrRange</code></a>. Panics if the range
is invalid.</dd><dt><a class="macro" href="macro.def_usize_addr.html" title="macro memory_addr::def_usize_addr">def_<wbr>usize_<wbr>addr</a></dt><dd>Creates a new address type by wrapping an <code>usize</code>.</dd><dt><a class="macro" href="macro.def_usize_addr_formatter.html" title="macro memory_addr::def_usize_addr_formatter">def_<wbr>usize_<wbr>addr_<wbr>formatter</a></dt><dd>Creates implementations for the <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug"><code>Debug</code></a>,
<a href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex"><code>LowerHex</code></a>, and <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex"><code>UpperHex</code></a>
traits for the given address types defined by the <a href="macro.def_usize_addr.html" title="macro memory_addr::def_usize_addr"><code>def_usize_addr</code></a>.</dd><dt><a class="macro" href="macro.pa.html" title="macro memory_addr::pa">pa</a></dt><dd>Alias for <a href="struct.PhysAddr.html#method.from_usize" title="associated function memory_addr::PhysAddr::from_usize"><code>PhysAddr::from_usize</code></a>.</dd><dt><a class="macro" href="macro.pa_range.html" title="macro memory_addr::pa_range">pa_<wbr>range</a></dt><dd>Converts the given range expression into <a href="type.PhysAddrRange.html" title="type memory_addr::PhysAddrRange"><code>PhysAddrRange</code></a>. Panics if the
range is invalid.</dd><dt><a class="macro" href="macro.va.html" title="macro memory_addr::va">va</a></dt><dd>Alias for <a href="struct.VirtAddr.html#method.from_usize" title="associated function memory_addr::VirtAddr::from_usize"><code>VirtAddr::from_usize</code></a>.</dd><dt><a class="macro" href="macro.va_range.html" title="macro memory_addr::va_range">va_<wbr>range</a></dt><dd>Converts the given range expression into <a href="type.VirtAddrRange.html" title="type memory_addr::VirtAddrRange"><code>VirtAddrRange</code></a>. Panics if the
range is invalid.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AddrRange.html" title="struct memory_addr::AddrRange">Addr<wbr>Range</a></dt><dd>A range of a given memory address type <code>A</code>.</dd><dt><a class="struct" href="struct.DynPageIter.html" title="struct memory_addr::DynPageIter">DynPage<wbr>Iter</a></dt><dd>A page-by-page iterator with dynamic page size.</dd><dt><a class="struct" href="struct.PageIter.html" title="struct memory_addr::PageIter">Page<wbr>Iter</a></dt><dd>A page-by-page iterator.</dd><dt><a class="struct" href="struct.PhysAddr.html" title="struct memory_addr::PhysAddr">Phys<wbr>Addr</a></dt><dd>A physical memory address.</dd><dt><a class="struct" href="struct.VirtAddr.html" title="struct memory_addr::VirtAddr">Virt<wbr>Addr</a></dt><dd>A virtual memory address.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.PAGE_SIZE_1G.html" title="constant memory_addr::PAGE_SIZE_1G">PAGE_<wbr>SIZE_<wbr>1G</a></dt><dd>The size of a 1G page (1073741824 bytes).</dd><dt><a class="constant" href="constant.PAGE_SIZE_2M.html" title="constant memory_addr::PAGE_SIZE_2M">PAGE_<wbr>SIZE_<wbr>2M</a></dt><dd>The size of a 2M page (2097152 bytes).</dd><dt><a class="constant" href="constant.PAGE_SIZE_4K.html" title="constant memory_addr::PAGE_SIZE_4K">PAGE_<wbr>SIZE_<wbr>4K</a></dt><dd>The size of a 4K page (4096 bytes).</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.MemoryAddr.html" title="trait memory_addr::MemoryAddr">Memory<wbr>Addr</a></dt><dd>A trait for memory address types.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.align_down.html" title="fn memory_addr::align_down">align_<wbr>down</a></dt><dd>Align address downwards.</dd><dt><a class="fn" href="fn.align_down_4k.html" title="fn memory_addr::align_down_4k">align_<wbr>down_<wbr>4k</a></dt><dd>Align address downwards to 4096 (bytes).</dd><dt><a class="fn" href="fn.align_offset.html" title="fn memory_addr::align_offset">align_<wbr>offset</a></dt><dd>Returns the offset of the address within the alignment.</dd><dt><a class="fn" href="fn.align_offset_4k.html" title="fn memory_addr::align_offset_4k">align_<wbr>offset_<wbr>4k</a></dt><dd>Returns the offset of the address within a 4K-sized page.</dd><dt><a class="fn" href="fn.align_up.html" title="fn memory_addr::align_up">align_<wbr>up</a></dt><dd>Align address upwards.</dd><dt><a class="fn" href="fn.align_up_4k.html" title="fn memory_addr::align_up_4k">align_<wbr>up_<wbr>4k</a></dt><dd>Align address upwards to 4096 (bytes).</dd><dt><a class="fn" href="fn.is_aligned.html" title="fn memory_addr::is_aligned">is_<wbr>aligned</a></dt><dd>Checks whether the address has the demanded alignment.</dd><dt><a class="fn" href="fn.is_aligned_4k.html" title="fn memory_addr::is_aligned_4k">is_<wbr>aligned_<wbr>4k</a></dt><dd>Checks whether the address is 4K-aligned.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.PageIter1G.html" title="type memory_addr::PageIter1G">Page<wbr>Iter1G</a></dt><dd>A <a href="struct.PageIter.html" title="struct memory_addr::PageIter"><code>PageIter</code></a> for 1G pages.</dd><dt><a class="type" href="type.PageIter2M.html" title="type memory_addr::PageIter2M">Page<wbr>Iter2M</a></dt><dd>A <a href="struct.PageIter.html" title="struct memory_addr::PageIter"><code>PageIter</code></a> for 2M pages.</dd><dt><a class="type" href="type.PageIter4K.html" title="type memory_addr::PageIter4K">Page<wbr>Iter4K</a></dt><dd>A <a href="struct.PageIter.html" title="struct memory_addr::PageIter"><code>PageIter</code></a> for 4K pages.</dd><dt><a class="type" href="type.PhysAddrRange.html" title="type memory_addr::PhysAddrRange">Phys<wbr>Addr<wbr>Range</a></dt><dd>A range of physical addresses <a href="struct.PhysAddr.html" title="struct memory_addr::PhysAddr"><code>PhysAddr</code></a>.</dd><dt><a class="type" href="type.VirtAddrRange.html" title="type memory_addr::VirtAddrRange">Virt<wbr>Addr<wbr>Range</a></dt><dd>A range of virtual addresses <a href="struct.VirtAddr.html" title="struct memory_addr::VirtAddr"><code>VirtAddr</code></a>.</dd></dl></section></div></main></body></html>