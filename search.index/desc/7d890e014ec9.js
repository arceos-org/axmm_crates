rd_("AjContains the success valueBlAlias for <code>PhysAddr::from_usize</code>.BlAlias for <code>VirtAddr::from_usize</code>.AhContains the error valueDmAdds a given <strong>unsigned</strong> offset to the address to get a new \xe2\x80\xa60BiThe upper bound of the range (exclusive).00BkReturns the end address of the memory area.CeReturns the number of memory areas in the memory set.CmWhat to do when mapping a region within the area with the \xe2\x80\xa6AiAdd a new memory mapping.BdCreates a new <code>PageIter</code>.BgCreates a new <code>DynPageIter</code>.CfCreates a new address range from the start and end \xe2\x80\xa6AjCreates a new memory area.AiCreates a new memory set.DnSubtracts a given <strong>unsigned</strong> offset from the address to get \xe2\x80\xa60BiThe address type used in the memory area.CfFinds the memory area that contains the given address.AoReturns the argument unchanged.0000000BaCalls <code>U::from(self)</code>.0000000BkReturns the iterator over all memory areas.AnReturns the size of the range.BdReturns the size of the memory area.BgThe flags type used in the memory area.CdRemove all memory areas and the underlying mappings.CdReturns the memory flags, e.g., the permission bits.BiThe lower bound of the range (inclusive).00BmReturns the start address of the memory area.CiWhat to do when unmaping a memory region within the area.CfRemove memory mappings within the given address range.BnConverts the virtual address to a raw pointer.ChAdds a given offset to the address to get a new address.0BoReturns the mapping backend of the memory area.BfWhat to do when changing access flags.ChChange the flags of memory mappings within the given \xe2\x80\xa6CaCreates a new address range from the given range.BiThe backend page table is in a bad state.AhA page-by-page iterator.AjA physical memory address.AiA virtual memory address.AfAlign address upwards.CbAligns the address upwards to the given alignment.0CkConverts an <code>PhysAddr</code> to an <code>usize</code>.CkConverts an <code>VirtAddr</code> to an <code>usize</code>.BoChecks if the range contains the given address.C`Returns <code>true</code> if the range is empty.DeReturns <code>true</code> if the memory set contains no memory areas.CjChecks if the range overlaps with the given address range.CmReturns whether the given address range overlaps with any \xe2\x80\xa6DhConverts the given range expression into <code>PhysAddrRange</code>. \xe2\x80\xa6CiSubtracts another address from the address to get the \xe2\x80\xa60DhConverts the given range expression into <code>VirtAddrRange</code>. \xe2\x80\xa6BbReturns the virtual address range.CfA range of a given memory address type <code>A</code>.DeA container that maintains memory mappings (<code>MemoryArea</code>).BlThe page table type used in the memory area.CfConverts the virtual address to a raw pointer of a \xe2\x80\xa6BaA trait for memory address types.CjA memory area represents a continuous range of virtual \xe2\x80\xa6BeA <code>PageIter</code> for 1G pages.BeA <code>PageIter</code> for 2M pages.BeA <code>PageIter</code> for 4K pages.DkConverts the given range expression into <code>AddrRange</code>. Panics \xe2\x80\xa6AhAlign address downwards.CdAligns the address downwards to the given alignment.0CfConverts the virtual address to a mutable raw pointer.CkConverts an <code>usize</code> to an <code>PhysAddr</code>.CkConverts an <code>usize</code> to an <code>VirtAddr</code>.CfChecks whether the address has the demanded alignment.00jmemory_setBoA page-by-page iterator with dynamic page size.BfAlign address upwards to 4096 (bytes).BkAligns the address upwards to 4096 (bytes).0DmAdds a given <strong>unsigned</strong> offset to the address to get a new \xe2\x80\xa60DnSubtracts a given <strong>unsigned</strong> offset from the address to get \xe2\x80\xa60CaCreates a new virtual address from a raw pointer.kmemory_addrBhGets the distance between two addresses.0EhInvalid parameter (e.g., <code>addr</code>, <code>size</code>, <code>flags</code>, etc.)BiError type for memory mapping operations.BiThe size of a 1G page (1073741824 bytes).BfThe size of a 2M page (2097152 bytes).BcThe size of a 4K page (4096 bytes).CgReturns the offset of the address within the alignment.CfReturns the offset of the address within the given \xe2\x80\xa60CiChecks if the range is contained in the given address \xe2\x80\xa6<<;;CbThe given range overlaps with an existing mapping.DlA <code>Result</code> type with <code>MappingError</code> as the error type.CdA range of physical addresses <code>PhysAddr</code>.CcA range of virtual addresses <code>VirtAddr</code>.BhAlign address downwards to 4096 (bytes).BmAligns the address downwards to 4096 (bytes).0CnConverts the virtual address to a mutable raw pointer of a \xe2\x80\xa6BiChecks whether the address is 4K-aligned.00ClCreates a new address range from the given range without \xe2\x80\xa6CjUnderlying operations to do when manipulating mappings \xe2\x80\xa6CeChecks if the range contains the given address range.CmCreates a new address type by wrapping an <code>usize</code>.CfFinds a free area that can accommodate the given size.CiReturns the offset of the address within a 4K-sized page.00CiCreates a new virtual address from a mutable raw pointer.CnCreates a new address range from the start address and the \xe2\x80\xa6DmAdds a given <strong>unsigned</strong> offset to the address to get a new \xe2\x80\xa60DnSubtracts a given <strong>unsigned</strong> offset from the address to get \xe2\x80\xa60ChAdds a given offset to the address to get a new address.0CiSubtracts another address from the address to get the \xe2\x80\xa6000400EbCreates implementations for the <code>Debug</code>, <code>LowerHex</code>, and \xe2\x80\xa65")