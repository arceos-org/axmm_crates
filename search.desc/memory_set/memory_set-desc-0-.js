searchState.loadedDescShard("memory_set", 0, "memory_set\nThe address type used in the memory area.\nThe given range overlaps with an existing mapping.\nThe backend page table is in a bad state.\nContains the error value\nThe flags type used in the memory area.\nInvalid parameter (e.g., <code>addr</code>, <code>size</code>, <code>flags</code>, etc.)\nUnderlying operations to do when manipulating mappings …\nError type for memory mapping operations.\nA <code>Result</code> type with <code>MappingError</code> as the error type.\nA memory area represents a continuous range of virtual …\nA container that maintains memory mappings (<code>MemoryArea</code>).\nContains the success value\nThe page table type used in the memory area.\nReturns the mapping backend of the memory area.\nRemove all memory areas and the underlying mappings.\nReturns the end address of the memory area.\nFinds the memory area that contains the given address.\nFinds a free area that can accommodate the given size.\nReturns the memory flags, e.g., the permission bits.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the memory set contains no memory areas.\nReturns the iterator over all memory areas.\nReturns the number of memory areas in the memory set.\nWhat to do when mapping a region within the area with the …\nAdd a new memory mapping.\nCreates a new memory area.\nCreates a new memory set.\nReturns whether the given address range overlaps with any …\nWhat to do when changing access flags.\nChange the flags of memory mappings within the given …\nReturns the size of the memory area.\nReturns the start address of the memory area.\nWhat to do when unmaping a memory region within the area.\nRemove memory mappings within the given address range.\nReturns the virtual address range.")